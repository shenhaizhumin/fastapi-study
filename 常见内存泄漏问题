
1.广播注册后没有及时反注册，服务开启之后没有及时关闭服务。
2.（非静态）内部类或匿名内部类导致的内存泄漏：
    非静态内部类或匿名内部类会持有外部类对象的引用，在没有及时解除关系情况下。常见的有handler，thread，AsyncTask
        handler通过sendMessage 发送消息，Message的target属性会指向当前这个handler，然后通过enqueue加入消息队列，如果是及时消息会唤醒loop线程立即执行该消息，
            如果是延时消息则不会唤醒loop线程。如有延时消息，当前消息还未执行，但是activity已经被销毁，此时未执行的message中的target持有handler的引用，handler
            作为内部类的形式出现在activity中会持有activity的引用，导致handler中activity的引用一直存在触发内存泄漏。
        thread：通常使用new thread的方法开启工作线程执行耗时任务，有可能在任务还未执行完成的时候activity已被销毁，这时候thread还在工作，
            导致其引用到的外部类activity的引用无法被回收
        AsyncTask 同上。
 3.占内存开销大，且非必须的对象（bitmap内存缓存）导致内存泄漏
    为了用户更好的体验，一般会将图片缓存到内存中，以便于下次加载更快速展现。将bitmap缓存到内存中，在需要复用的时候取出来，如果使用强引用存储bitmap，
    在图片很多的列表里面，内存会马上吃紧，这时候使用的若是强引用缓存图片（java虚拟机退出的情况下被回收），势必难以回收导致OOM，
    若是使用弱引用，虚拟机执行GC操作扫描到的弱引用会被回收，若是使用软引用，当内存不足的时候会被回收。
